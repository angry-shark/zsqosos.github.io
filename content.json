[{"title":"骑行在大雨滂沱的夜","date":"2017-07-07T16:21:27.000Z","path":"posts/life/20170708-cycling-in-the-rain/","text":"今天喝了点酒，以下内容都可以当做酒后的胡说八道，完全不必当真。我的直属领导自己开了家公司，晚上请大家伙吃饭，竟也叫上了我这无名小卒，我自然不会辜负领导的一番美意，所以在桌上便喝了一点小酒。了解我的朋友都知道我是一个不爱喝酒并且不喝酒的人，甚至可以说十分厌恶喝酒，酒量也不过就一瓶啤酒，但每次和真正的朋友在一起，我总会爽快的喝两瓶。 东边的夜还很晴朗，西边却是大雨滂沱，而我恰好住在西边。同领导吃完饭已经十一点多了，末班地铁早已停运，北京也不是京都，没有类似于深夜食堂这样的小店让我可以避避雨，无论如何我也得硬着头皮回家。同事开车送我到地铁口，我也不好意思再麻烦人家，就谎称再走几步就到家了，其实还有一大截要走。喝完酒，在大雨滂沱的夜里骑个共享单车回家，这种感觉也很爽，唯一不爽的就是一辆开的贼快的丰田车溅了老子一身水。这种雨中骑行的经历我估计以后也都很少有，所以偶尔经历一次感觉也蛮不错。记得大二军训的时候，晚上突然下起了大雨，虽说只有百十来米的距离，但冒雨跑回宿舍就已浑身湿透，今晚又有了当初的感觉，唯一不同的是，在雨中和我一起穿行的人变了。 大半夜打不起车，只能在雨里骑车穿行，有人会觉得这很辛苦，我却不这么认为。我觉得能做自己喜欢的事，即使过的窘迫也没关系。我不愿光鲜亮丽却无聊的活着，若失去了思想，倒不如不要活着。如今我每天可以做自己想做的事，没有人能限制我回了家做什么，这比我在在工地待着要强多了，失去了自由的生活我宁肯不过。我毕生的追求的就是精神的自由，而不是物质的富足，当然在当前这个阶段，物质对我来讲也十分重要，但最终，精神世界带给我的快乐一定是物质世界不能比拟的。 《黑客帝国》里的塞佛说“无知就是快乐”。的确，如果我没有上过大学，没看过这些乱七八糟的书，我就不会有这些别人不理解的想法，现在的我可能就是一个普通的庄稼人，托人找邻村的姑娘结婚，然后快乐的过完普通平淡的一生。我并不是说这样不好，能平淡的过完一生就是最大的幸福。但是，偏偏我考上了大学，又偏偏看了很多乱七八糟的书，这一切让我认识到了人原来还可以有不一样的活法，学医的鲁迅先生发现医学并不能解救麻木的人们，他知道必须从精神层面去改变他们，他便选择了弃医从文。同样，如果我不知道人生有不一样的活法，我就会很安稳的过完一生，可是不幸的是，我明白了人生可以过得很丰富，我就不会再甘于平淡而安稳的生活。我多希望自己不知道这个世界有这么大，这样便能轻易获得快乐，可惜的是，我自己葬送了这种快乐，却在这婆娑世界的小小夹缝中追求自由，以此来获得快乐。 当我和朋友需要共同决定一件事的时候，我总会顺从他们的意见，而当我需要自己决定自己的人生的时候，我却十分主观，别人的意见对我来讲，并没有太大用处，原因很简单，正如我博客的签名，“我与我周璇久，宁做我”。我与我自己也周旋了很久，做自己其实很难，要忍受很多外界的白眼，甚至是别人的指责，但我也会坚持下去。在我身边，我从没见过这样的人。但是，这种人是真实存在的，最近朴树去参加了一个著名的歌唱节目，原谅我忘记了节目名字，我向来对这些节目不太关心，主持人问他为什么来这个节目，他说“我最近确实很缺钱，人总是要吃饭吧”。我很喜欢这样的答案，简简单单、真真切切，没有那些听惯了的虚情假意，不用估计别人的感受，不用去想大家怎么看、怎么想。有人说，你这么说话考虑过别人的感受嘛，好像是没错，但是我们好像都忘了，我们到底是为了谁而活？难道真的需要时时刻刻去为了考虑别人的感受而放弃表露心声吗？这样活着得多累啊。 人是一种社会性动物，一个失去了社会性的人，要么是真正的大师，要么就是疯子。现在太多人做的事情，都是为了得到社会的认可，而不是跟随自己的本心，慢慢的人们就忘记了为什么要做这些，从而失去了自己的真性情，变成一具在社会中游荡的皮囊。人的社会性和真性情是矛盾的，若想做自我，就必须承受一些社会的不满，若只追求社会性，那便迷失了真正的自我。对普通人来说，我们都在真性情与社会性之间波动，使之达到一个动态的平衡，而那些真正敢于表现真性情的人往往会成为人们仰慕的对象，但人们仅仅停留在仰慕的阶段，不愿去打破自己的平衡，人们偶尔也会冲动一下，表露出自己的真性情，但事后也往往会后悔自己当时这么做。初读《红楼梦》的时候，我就很讨厌林黛玉，喜欢薛宝钗，我讨厌林黛玉的刻薄小性，喜欢薛宝钗的世故与稳重。等我多读几遍之后，我慢慢开始喜欢林而讨厌薛了，因为林的刻薄小性正是她真性情的表现，薛的作为则完全是为了迎合社会性需求。薛是无论如何不会表现林的那种感情的，即使她们心中的想法相同，林黛玉会全然表现出来，而薛宝钗会把自己的真实想法包装一下，表现出更有利于自己的行为。我是一个厌恶世俗的人，所以我很希望自己能像林黛玉那样坚持自己的真性情。但有时候自己却俗不可耐，表现出一幅深谙世事的样子，我注定成不了林黛玉或者朴树那样的人，但我希望自己尽量去保持自己的真性情，千万别再社会中丢失了自我。 所谓的真性情其实就是跟随本心，敢于将心中所想、所悟表露出来，而不是为了迎合别人而去指鹿为马。这是我这半生缺失了很久的东西，我需要慢慢的把它找回来。《金刚经》中说“凡一切相，皆为虚妄。若见诸相非相，即见如来”。我们所看到的东西都是“相”，马也好，鹿也好，都不过是一种世界的意识形态，而心才是最重要的，心可以决定所看到的“相”，若执意指着鹿说这就是马，也没什么问题，但是有一个前提，就是内心真的看到这是一匹马。若心中认同这是马，而不只是简单的嘴上说说，那也就达到了看所有“相”都不再是“相”了，也就修得正果了。这么说好像有一点唯心主义的色彩，可唯心主义是有其合理性的，现在的我也算的上是半个唯心主义者。我们常说不忘初心，方得始终，其实左右也逃不过一个“心”字。我现在还达不到“诸相非相”的境界，但我最起码要保持本心，做一个敢爱敢恨、敢说敢做的自由人。 写在后面的话：现在已经凌晨三点钟了，写完这些废话，好像已经清醒了不少，人都说酒后吐真言，这些东西是真言还是胡话，我也不清楚了。不清醒的时候写的东西，难免语句不顺，错字连篇，但我也不打算改了，既然喝了酒，至少也得表露出一点酒后的真性情吧。","tags":[{"name":"杂记","slug":"杂记","permalink":"http://zsqosos.github.io/tags/杂记/"}]},{"title":"外婆","date":"2017-07-02T14:16:54.000Z","path":"posts/life/20170702-grandmother/","text":"外婆生在那个战乱的年代。她从没有上过一天学，一辈子也不认识几个字，一生过着穷苦的生活，年轻时候的她一定过得很辛苦。如果可以，我很想看一看年轻时候的外婆。可惜那个时候，普通人没有相机，我更没机会看到外婆年轻时的样子。当外婆拍出她第一张照片的时候，她的脸上已写满了岁月的痕迹。 前几天和外婆通视频电话，外婆看到手机屏幕上的我，高兴的像个孩子，不停的问我什么时候回家，我说国庆放了假就回去，她说你过年离开家都五个月了，你是去外地了吧，你不用瞒着我。我笑着说没有，我就在西安，离家很近的，放了假我马上就回来。 来北京有些时候了，每天过着千篇一律的日子，让我自己都已忘记我来了这里有多久,外婆却记得比我还清楚。还记得临走前，为了不让她担心，我告诉外婆，我要去西安工作，不用担心我，离家这么近，一有空我就会回来的。偶尔撒撒慌并没什么不好，当然前提是不要被识破，如今看来，我在这方面确实没什么天赋，而死皮赖脸硬撑的本领倒是有一些。外婆现在眼睛越来越花了，耳朵也不再灵光，偶尔还会犯犯糊涂，所以有时候我会把外婆当小孩子看待，觉得哄一哄她，她也不会知道。可是，我却忘了，我才是真正的孩子，她是看着我长大的，怎么可能会不懂我那一点点小心思。在我眼里，有些事外婆并不清楚，可其实她全都清楚。 外婆说“你不要给我买东西，我现在有吃有穿，每月还能领到国家的钱，这就很好了。你的钱拿去多买点吃的，在外面可要吃饱，不敢为了省钱饿肚子”。对外婆来说，在那个年代，能吃饱饭应该就是莫大的幸福了。所以，她希望我不要经历她曾经受过的苦，她会经常叮嘱我要好好吃饭。每次回到家，外婆都会说你怎么又瘦了，要多吃饭。我说我要是吃成个大胖子再回来，你可就不认识我了，外婆笑的前俯后仰，笑完了，还要告诉我：“你胖成啥样我可都认的出来”。关于这点我一直不大相信，毕竟有一次外婆可是连自己的亲儿子都没认出来。那是在一个吃过饭的午后，外婆坐在门口晒太阳，大舅买了好些东西来看外婆，看到外婆在晒太阳，就说了句：“今这个天气可真好”，外婆也回了一句：“日头好的很嘞”。然后大舅就进屋里放东西去了，这时候外婆转头问我：“刚那人是谁啊？”我听完就乐了：“这是我大舅啊，你咋连你亲儿子都不认识了，哈哈哈，哈哈”，然后大舅出来了，外婆端详了好一会儿，认出那人真是大舅，自己也跟着笑了。 这几年，外婆的眼睛大不如从前了，认错人的情形时常发生，但是每次我回家她总能一眼认出来，当然这都是在我没吃成胖子的前提下。我多希望她的眼睛能和从前一样明亮，这样就算我真成了大胖子，她也能一眼认得出，所以每次回家我都会给她买那些药方上的眼药水，可惜那些滴进外婆眼睛里的药水，并没能让她眼睛变得光明，但我看的到，每当我拿出那些微不足道的眼药水，她的脸上都挂满了笑容。 我待在家里的时候，外婆总喜欢拉着我的手跟我聊天，虽说是聊天，但大部分时间都是她在说，我在听。她说多久，我就坐在在旁边听多久。外婆一生没怎么经历过外面的大千世界，她只懂那些发生在她身边的事，与我聊天的内容也通常就是张三家的孩子去哪儿上学了，李四家又养了多少只鸡之类的事情，偶尔她还会讲讲小时候的我，听这些事并没有什么意思，但能跟外婆坐在一起聊天，我就很高兴了。我高兴，不是因为外婆讲这些普通的事而高兴，而是看到外婆高兴而高兴。 小时候，我需要大人照顾，外婆总会陪着我，如今，我长大了，外婆却老了，现在她成了那个需要照顾的人，我却不能陪在她身边。她要的是陪伴，而不是六百块，说起来是那么简单，而我想要办到却是那么难。我现在没什么的愿望，只希望外婆每天都能过得快乐，而我能再多给她一些陪伴。","tags":[{"name":"杂记","slug":"杂记","permalink":"http://zsqosos.github.io/tags/杂记/"}]},{"title":"旧日与往事","date":"2017-06-25T14:46:15.000Z","path":"posts/life/20170625-graduation-memories/","text":"长亭外，古道边，芳草碧连天。晚风扶柳笛声残，夕阳山外山。 每年的这个季节，都会有一群群青年互道告别，给陪伴了四年的好友道声珍重，然后像一名战士一样踏上新的征程。而在去年，我正是他们中的一个。 去年的这个时候，离毕业离校已不剩十天，毕业后的事情也都已安排妥当，所以除了白天拍毕业照之外，也别无他事，每天一块喝酒吹牛逼自然就成了我们缅怀大学生活以及互道告别的方式。那时候我们每晚都会在楼下小商店买很多辣条，抱两箱啤酒回宿舍，三个宿舍的人凑在一起吃吃喝喝，喝到兴头，还要玩一玩“逛三园”这种老把戏，在酒精的刺激下，混沌的大脑早已跟不上急需快速吐词的嘴，这时候喝多的人嘴里总会冒出“土铃薯”、“马龙果”之类的新新词汇，这些从不曾听说过的奇特物种总能惹得一众傻逼捧腹大笑，宿舍里也充满欢快的气氛，也只有在这种欢乐的气氛下我才能暂时忘掉将要离别的不舍。我是一个不善表达感情的人，即使和自己最亲近的人，也羞于去表达自己内心的情感。到了毕业，即便内心有伤感的情绪，也要强装镇定，表现出一副满不在乎的样子。我曾经甚至认为离别时的伤感像是一种矫情，大老爷们离别应该有那种“莫愁前路无知己，天下谁人不识君”的豪迈，但当真正到了要离开的时候，我的豪迈也找不到了，真正的感情是控制不了的。 最后一次班级聚餐，大家都喝了很多酒，彼此诉说着离别的祝福，说出四年都不曾说出口的话，在班服上互留签名，起身互换拥抱。一切都是那么的自然，离别的情绪在此刻凝聚成一个奇点，而这种情绪继续发酵的结果就是奇点的崩塌与无限扩大。我一直觉得自己有宠辱不惊的气概，但是当一同住了四年的兄弟趴在饭桌上哭的像个傻逼的时候，我那心头的酸楚竟如洪水决了堤，一瞬间将我那份豪气冲的一干二净。这时候我才意识到，我们半夜一起翻墙去唱歌，一起上夜机打英雄联盟，翘课让下铺的兄弟替答到，窝在宿舍打游戏让隔壁兄弟带饭的日子都已经成为了过去，曾经的日子就这么结束了。是的，一切就这样结束了。 毕业前最后一次喝酒是在老朱过生日的时候，也就是一年前的今天。犹记得那天，二十多个人在老板店外面分好几桌坐下，喝着啤酒撸着串，和同窗四年的好友吹着牛逼，扯着过去的回忆，谈着憧憬的未来。可惜欢乐的时光总是那么短暂，酒还没有喝完，煮熟的菜还没吃完，想要说的话还没说完，老板就告诉我们该散场了，就如同我们还没想走出校园，但青春就已经散场了一样。那天晚上，有人喝的走不动道，有人喝的嘴里语无伦次，而我那天一直十分清醒，回去的路上搀扶着喝醉的兄弟，把同行的女同学送到宿舍楼下，回到宿舍安顿好喝醉的兄弟，自己躺在床上的时候，我却很想大醉一场，也向逝去的时光宣泄我的不满，为什么你要走的这么快。 离校的前几天，我出门去寄放行李，回来的路上碰上一些有趣的事情，憋了一肚子话想回到宿舍说，回去推开门却发现宿舍里空无一人，诺大的房间只剩光溜溜的床板和整好的行李，当时的我仿佛吃了一记闷棍。我想我今生都不会再有当时那种失落了吧。 日子一天天过去，时间并没有因为我们伟大的革命友谊而停留。七月份，学校也发出了最后离校的期限，我们仿佛一个个尚未成年的孩子，而父母却已发出最后通牒要我们走出家门去自寻生路。当时还在感慨母校为何如此无情，不能让我们多待几日。现如今回头去看，发现这不过是再普通不过的规律，有聚就会有散，从踏入校园的那天起，就注定会有离开的一天。我们就像是一批批过客，离开的时候，除了回忆，留不下任何东西。而母校就是一张温床，它给了我们很多庇护，但最终我们还是要走出那张温床，自己去面对江湖上的刀光剑影。 毕业至今已有一年时间，而往事却依旧历历在目，这一年恍如一场梦，梦醒来就已如此。一年时间，并不算长，但足以改变很多事，以前常去吃的饭馆不知搬去了哪里。曾经最熟悉的英雄，技能也变得不认识。有的人慢慢失去了联系，也有一些新朋友走进了我的生活。但无论如何，我很感谢所有在我人生里出现过的人和事，感谢你们留给我的美好回忆。如今，我还在为自己的追求苦苦挣扎，身边的朋友也都在为了未来而努力。毕业一年了，朋友，但愿你们都能过得更好，都可以早日实现自己的梦想。我是一个不善于主动的人，如果我没有主动联系你，我想给你说声抱歉，我从来没有忘记过你，我会试着慢慢改变，去主动联系你，但希望在没联系你的日子里，你别忘了我。人生的路还长，我希望我未来的人生处处有你。 ——2017年6月25日夜","tags":[{"name":"旧事","slug":"旧事","permalink":"http://zsqosos.github.io/tags/旧事/"}]},{"title":"大白话谈互联网协议","date":"2017-05-19T14:17:54.000Z","path":"posts/program/20170519-internet-protocol/","text":"你的问题在这个宁肯不吃一顿饭，不可断一小时网的时代里，我们对网络的依赖已经达到了无以复加的地步，虽然我们每天在使用网络，却并不清楚网络通讯到底是如何进行的？ 比如，你在微信里给苦追了好久的姑娘发送了一条约会消息，她收到了，并且在微信上回复给你“不好意思，我今晚有约了”，但是这可能是个误会，你发送的消息为什么可以成功到达她的手机上，而不是被远在大洋彼岸的川普收到呢？她在手机上看到这条消息后，回复给你一条拒绝的消息，这条消息也准确无误的被你所接收，本来打算和姑娘一块看电影的计划泡汤了，虽然你这时候心情很糟，但你也无事可做，所以打算研究研究这该死的网络通讯协议。看看为什么你发给妹子的消息没有发到川普的手机上。 简单分析我们先来看看你给姑娘发送消息这一过程，它的背后到底发生了什么。首先，你编辑了一条消息，点击了发送按钮，这时这条消息会被经过包装，然后发送至腾讯的服务器上，包装的过程中，会把发送人、接收人、消息内容等等信息整合在一起，腾讯的服务器接收的这条信息之后，对应的程序就会对这条消息进行处理计算，从而得知要把什么内容发送给什么人，然后服务器也将这一信息进行包装处理，发送出去，之后姑娘收到消息。这只是一个简单的消息传递流程，要想真正搞清楚消息是怎么发送的，还需要了解互联网通讯的原理。 协议首先我们要知道协议是什么？其实很简单，协议其实就是一种规则。比如在社会中，我们有法律来约束每个人的行为，法律就可以看做是一种面向公民的“协议”。在互联网上我们同样需要一些规则来约束各个主机设备或程序的行为，那么这个规则就是互联网协议。接下来我们会介绍互联网分层模型，互联网的每一层都有其特定的功能，要实现这特定的功能就要有对应的协议。 互联网分层模型为了便于理解，我们一般可以将互联网通讯模型分为五层，每个层都有它自己的功能。物理层是最底层，应用层是最高层，中间分别是链路层、网络层和传输层，其每一层都是建立在上一层的基础上的。 （一）物理层你想给姑娘发送一条消息，首先你得有个手机（这TM不是废话），其次，你的手机得连上网（这TM也是废话），或许你这条消息是用电脑版的微信发送的，那无论你是插网线还是连WIFI，都需要你成功接入互联网。 这些连接线路就是互联网的物理层，物理层主要功能是提供了数据传输的介质，使得电信号可以在设备之间传播，这里的电信号也可以简单的理解为0或1。 （二）链路层物理层为我们提供了在两台设备之间传输0和1的可能，但是只是单纯的传输0和1是没有意义的。链路层的作用是将这些01信号序列化，转化为有意义的数据帧。 那么链路层是怎么工作的呢？它工作过程大概可以理解为三个部分，发送什么数据？发送给谁？怎么发送？ 首先需要有一个规则来定义这些01电信号，使得这些电信号变得有意义，这个规则就是以太网协议（Ethernet），它规定了一组电信号为一个数据包，每个数据包都分标头(head)和数据(data)。标头用来存储发送人、接收人、数据类型等等，数据部分就是消息内容。这就解决了发送什么消息的问题。 定义好了数据，我们就该考虑发送给谁的问题了，每台设备都有自己的一个地址，叫做MAC地址。MAC地址在设备出厂时就已经固定了，这个地址在全世界是独一无二的，这样我们就可以通过这个地址去向目标设备发送数据。 虽然我们知道了目标设备的MAC地址，但是怎么才能把把消息准确的发送给目标设备呢？其实解决方法很简单，发送数据时，将向网络中所有设备都发送这个消息，然后每一台设备自己来判断数据标头中包含的MAC地址是否和自己的MAC地址一致，如果一致就接收这个消息，如果不一致就不接收。这种发送数据的方式叫做“广播”。通过“广播”的方式就可以把一条数据发送到指定设备上了。 好了，让我们再来看看发送数据这个过程，如我们上面所说，你想给姑娘发送一条消息，得通过通讯线缆传输0或1这种信号，然后有一种叫以太网协议的东西可以帮你把01信号转化为有意义的数据，之后你的手机向网络中所有设备发出这条消息，姑娘的手机发现这条数据是发给她的，便接受了这条数据，其他人的设备发现数据中包含的MAC地址和自己的MAC地址不符合，说明这条数据是发送给其他人的，便不接收这条数据。这样便达到了发送给姑娘消息的效果。 （三）网络层我们知道全球的可联网设备都在一个巨型网络下，按我们上面所说，你的消息会发送给网络内所有设备，这么说来你的这条消息还是发给川普了嘛，只是人家没有接收而已。其实，并非如此，如果每发送一条消息都会发送给互联网上的所有人，那以互联网这么大的体量，早就瘫痪了。 实际上，“广播”的方式只能在同一子网络内发送数据，互联网是由非常多的子网络组成的巨型网络，所以你发给姑娘的消息川普是绝对收不到的。 看到这里你肯定已经明白了，网络层的作用是可以让数据在不同子网络之间也可以传递。最常见的网路层通讯协议就是IP协议。 3.1 IP地址虽然每台设备都有自己独有的MAC地址，但是通过MAC地址我们是无法判断该设备是属于那个子网络的，所以我们引入了一种其他的地址，叫做IP地址，也称为“网址”。目前最常使用的是IPv4，是IP协议的第四版。IPv4规定网址是由32位二进制数组成，通常以四段10进制数表示，从0.0.0.0到255.255.255.255，例如：192.168.1.1就是一个IPv4地址。 3.2 子网掩码有了两台设备的IP地址，我们该如何判断两台设备是不是处在同一子网络下呢？这时候就需要另外一种叫做“子网掩码”的参数了，“子网掩码”同IP地址十分类似，也是由32位二进制数组成，不过它的网络部分全部为1，主机部分全部为0，那么什么是网络部分？什么是主机部分呢？ 举例来说，IP地址为192.168.1.1，子网掩码为“255.255.255.0”，就表示此IP的前24位为网络部分，后8位为主机部分。也就是说通过“子网掩码”可以确定一个IP地址的网络部分和主机部分。那么问题就变得简单了，如果两台设备的IP地址网络部分是相同的，那么他们就处在同一子网络。 例如：A设备的IP地址为172.12.214.3，子网掩码为255.255.0.0，B设备的IP地址为172.12.213.1，子网掩码同为255.255.0.0，则可以判断出A设备与B设备处在同一子网络下。 3.3 相同子网络间的数据传输好了，看起来费了好大的劲来判断两台设备是不是处于同一网络下，但是相信我，费这么大功夫是绝对值得的。我们马上就可以在互联网上任意两台设备间发送数据了。首先我们要了解，我们想要发送数据，就必须知道目标设备的IP地址和MAC地址。 通过IP协议，我们可以判断出要传输数据的两台设备是否是在同一子网络，那现在就会有两种情况，第一种情况是，两台设备处在同一子网络下，那我们就可以利用“广播”方式去发送数据了，但是问题来了，知道目标设备的IP地址，如何获得目标的MAC地址呢？这时候ARP协议就登场了。 ARP协议的作用可以简单的认为是通过IP地址来获取同一子网络中设备的MAC地址，那它是如何工作的，其实也很简单，它也是通过“广播”的方式向子网络内所有设备发送一条数据包，数据包中的MAC地址填写为：FF:FF:FF:FF:FF:FF，这样当其他设备收到这条数据的时候，就会对比自身的IP与数据包中的IP是否一致，若不一致就丢弃这条数据，若一致就接收这一条数据，并汇报自己的MAC地址，这样就可以通过IP地址获取到MAC地址了。 现在我们就可以在两台设备（同一子网络）间通讯了。 3.4 不同子网络间的数据传输第二种情况是，要传输数据的两台设备，不在同一子网络下，我们知道，要想把数据准确发送到目标设备中，就必须知道两个地址 目标设备的IP地址 目标设备的MAC地址 但是，不同子网络间的两台设备，是无法获取到对方的MAC地址的，这时候只能将数据包发送给网关，网关通过路由协议再将数据发送到目标设备上。所以这时候需要知道的地址就变成了 目标设备的IP地址 网关的MAC地址 如图，主机2想向主机4发送一条数据，必须先将数据发送至网关A，由网关A通过路由协议查询到主机4处于子网络B，网关A会将数据发送给网关B，网关B再将数据发送给主机4，这样便完成了主机2到主机4之间的通讯。 至此，我们应该清楚了，在两台设备间通讯所必须的条件，首先我们需要判断两台设备是否处在同一子网络中，若在同一子网络，就可以利用ARP协议来获取MAC地址，得到目标IP和MAC地址，就可以发送数据。若不在同一子网络，则需要获取网关的MAC地址，将数据发送到网关，让网关来转发。现在我们就可以在互联网上任意两台设备间通讯了。 （四）传输层通过上面的介绍，我们已经知道了两台设备之间是如何通讯的了，但是，当你收到姑娘回给你微信消息的同时，你的手机还在线播放着久石让的《summer》，那么问题又来了，你的手机同时接收着两种数据，那系统为什么不会把微信的数据和网易云音乐的数据搞混呢？ 不同的应用程序在主机上发送或接收数据，都要通过不同的端口（port），以此来确定数据包是归那个应用程序所有。 传输层的作用就是定义了端口到端口之间的通讯，最常用的协议是TCP协议。这个协议比较复杂，它可以保证数据不会丢失。常说的“三次握手”和“四次挥手”就是指TCP协议的建立和断开，有时间的朋友可以更加深入的了解了解TCP协议。 （五）应用层虽然各个应用程序都能拿到自己对应的数据，但是如果不对这些数据进行规范，应用程序也无法解读。所以在应用层出现很多协议，用来为应用程序提供特定的数据服务接口，这些服务包括文件传输、文件管理以及电子邮件的信息处理等。例如浏览网页需要HTTP协议、下载文件需要FTP协议，读取邮件需要POP3协议等等。 最后，我们在来看一张图，想一下互联网每一层都主要做了什么 数据形式在这个五层模型中，每一层都有其对应的数据，物理层的数据就是0和1，链路层将0和1序列化定义为“帧”，“帧”分为标头和数据两部分。网络层的数据为IP数据包，它也有头部和数据两部分，IP数据包是放在帧的数据部分中的。传输层中的TCP数据包也分为头部和数据两部分，它放在IP数据包的数据部分。应用层的数据直接放在TCP数据包的数据部分。所以最终的数据形式就变成了以下形式 分层来看的话如下 总结这片文章只是从基础的角度简单的介绍了互联网通讯的大概原理，其中简化了很多部分，实际通讯过程要比文章所写复杂的多，要想弄清楚详细的互联网通讯过程，还需要对各个协议做更加深入的学习。文章参考了阮一峰老师的互联网协议入门，阮老师这两篇文章通俗易懂，是互联网协议入门的不二之选，本文若有描述不清楚的地方，大家可去阅读阮老师的互联网协议入门。本文是在初步学习了互联网协议之后，自己做的一些总结，文中若有不对之处，欢迎指正。","tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://zsqosos.github.io/tags/网络协议/"}]},{"title":"三月的北京","date":"2017-03-20T12:48:38.000Z","path":"posts/life/20170320-beijing-in-march/","text":"漫天飞舞的柳絮，随着耳机里的旋律化作思绪，飘进了我的心。初来北京，虽说正值春日，但除了每日的工作和学习，还未曾出门踏踏青。我并不是一个喜欢游玩的人，但出门看到一番好景致自会让人心情大好。看着眼前的场景，我想，三月的北京似乎和别处一样，但似乎又不一样。玉渊潭那熙熙攘攘的赏花者和别处并没什么不同，连园子里的花也和别处一样，而这里的热闹却是别处没有的。年年均有花开时，花开自会惹人赏。而今旧人非今人，此花亦非旧时花。我似乎来的正是时候，有幸目睹今年盛开的樱花。 三月的北京很柔弱，处处都是一副惹人怜的模样路边轻摆的杨柳湖上悠悠的小船还有街上那美丽的姑娘 三月的北京也很豪壮有胡同里一口京腔骂仗的少年也有紫禁城宏伟壮阔的雄景更有无数人为之努力的梦想 在这座城市里每天都有许多人为了生活而奔波更有人为了梦想而奋斗有人在这里看到了无尽的黑暗有人在这里看到了希望之光我想人生的意义可能不在于得到什么，而在于做了什么三月的北京是什么？不是美景是希望","tags":[{"name":"杂记","slug":"杂记","permalink":"http://zsqosos.github.io/tags/杂记/"}]},{"title":"两种最常用的Sticky footer布局方式","date":"2017-03-08T11:22:52.000Z","path":"posts/program/20170308-stickyfooter/","text":"Sticky footer布局是什么？我们所见到的大部分网站页面，都会把一个页面分为头部区块、内容区块和页脚区块，当头部区块和内容区块内容较少时，页脚能固定在屏幕的底部，而非随着文档流排布。当页面内容较多时，页脚能随着文档流自动撑开，显示在页面的最底部，这就是Sticky footer布局。 图示说明 当内容较少时，正常的文档流效果如下图 在正常的文档流中，页面内容较少时，页脚部分不是固定在视窗底部的，这时就要用到Stickyfooter布局。 Sticky footer布局效果如下图 这样就符合我们的预期效果，可以看出Sticky footer布局的应用场景还是非常广泛的。 实现方式负margin布局方式html代码： 12345678&lt;div class=\"wrapper clearfix\"&gt; &lt;div class=\"content\"&gt; // 这里是页面内容 &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt; // 这里是footer的内容&lt;/div&gt; css代码：12345678910111213141516171819202122.wrapper &#123; min-height: 100%;&#125;.wrapper .content&#123; padding-bottom: 50px; /* footer区块的高度 */&#125;.footer &#123; position: relative; margin-top: -50px; /* 使footer区块正好处于content的padding-bottom位置 */ height: 50px; clear: both;&#125;.clearfix::after &#123; display: block; content: \".\"; height: 0; clear: both; visibility: hidden;&#125; 注意:content元素的padding-bottom、footer元素的高度以及footer元素的margin-top值必须要保持一致。 这种负margin的布局方式，是兼容性最佳的布局方案，各大浏览器均可完美兼容，适合各种场景，但使用这种方式的前提是必须要知道footer元素的高度，且结构相对较复杂。 flex布局方式html代码： 1234&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;这里是主要内容&lt;/div&gt; &lt;div class=\"footer\"&gt;这是页脚区块&lt;/div&gt;&lt;/div&gt; css代码： 1234567891011.wrapper &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;.content &#123; flex: 1;&#125;.footer &#123; flex: 0;&#125; 这中布局方式结构简单，代码量少，也是较为推荐的布局方式。 小结Sticky footer布局是十分常见的一种页面布局形式，实现的手段也比较多，以上两种方法最为常用，且基本可以满足所有应用场景。","tags":[{"name":"css","slug":"css","permalink":"http://zsqosos.github.io/tags/css/"}]},{"title":"原生js实现天气查询小应用","date":"2017-01-16T08:55:40.000Z","path":"posts/program/20170116-weather/","text":"介绍用原生js实现了一个简单的小应用，可以用来查询全国天气，主要实现了以下两个功能 点开链接时，页面自动获取当前所在城市，并显示所在城市的天气信息 在搜索栏搜索要查询的城市，可显示要查询城市的天气信息 页面效果如下： 预览 在线预览 完整代码 请使用高级浏览器查看，预览时若速度较慢，请耐心等待 实现原理1.用jsonp的方式请求天气数据由于现有免费天气api较少，在此推荐两个api nowapi 百度地图开放平台 这两者都是可以免费使用的，nowapi的免费天气数据可以提供未来7天天气数据，百度地图的api可以提供当前所在地理位置及当日天气详情，结合使用基本可以满足个人需求 百度天气api测试示例：http://api.map.baidu.com/telematics/v3/weather?location=西安&amp;output=json&amp;ak=FK9mkfdQsloEngodbFl4FeY3 newapi天气api测试示例：http://api.k780.com:88/?app=weather.future&amp;weaid=1&amp;&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json) 以上地址仅供测试使用，若需使用，请单独申请key。另外，以上数据接口均支持https，并支持jsonp调用 jsonp方式的数据请求函数 123456function jsonp(url)&#123; var script = document.createElement('script'); script.src = url; document.body.insertBefore(script, document.body.firstChild); document.body.removeChild(script);&#125; 将上述天气api地址传入此函数，便可得到天气数据，对于请求所需参数及返回数据格式请参考官方api文档，在此不再赘述。采用jsonp的方式可以完美解决跨域的问题，但需注意一点，使用https协议的站点也只能调用支持https的api接口 返回数据如下 返回的数据为json格式，由于我的chrome安装了JSONview插件，所以可以看到格式化后的json数据 2.将返回数据展示在页面上这一步比较简单，主要是用js操作dom，将对应的数据填在页面相应的位置上，除了文字数据外，还需对天气图标进行操作，使之与天气相对应。返回的数据中已含有天气图标url，只需根据返回数据动态改变原有html中img的src即可。但由于以上api所提供的天气图标太丑，所以我采用了自己的天气图标来替换 主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//调用jsonp函数请求当前所在城市jsonp('https://api.map.baidu.com/api?v=2.0&amp;ak=Dv1NMU23dh1sGS9n2tUouDEYY96Dfzh3&amp;s=1&amp;callback=getCity');window.onload=function()&#123; //请求天气车数据 btn.onclick=function ()&#123; jsonp(createUrl()[0]); jsonp(createUrl()[1]); &#125;&#125;;function getCity()&#123; function city(result)&#123; //去掉城市名后的\"市\" var city = result.name.substring(0,result.name.length-1); //请求当前城市的天气数据 jsonp(createUrl(city)[0]); jsonp(createUrl(city)[1]); &#125; var cityName = new BMap.LocalCity(); cityName.get(city);&#125;// 数据请求函数function jsonp(url)&#123; var script = document.createElement('script'); script.src = url; document.body.insertBefore(script, document.body.firstChild); document.body.removeChild(script);&#125;//数据请求成功回调函数，用于将获取到的数据放入页面相应位置function getWeather(response) &#123; var oSpan = document.getElementsByClassName('info'); var data = response.result; oSpan[0].innerHTML=data[0].citynm; oSpan[1].innerHTML=data[0].days; oSpan[2].innerHTML=data[0].week; oSpan[3].innerHTML=data[0].weather; oSpan[4].innerHTML=data[0].temperature; oSpan[5].innerHTML=data[0].winp; oSpan[6].innerHTML=data[0].wind; var aDiv = document.getElementsByClassName('future_box'); for(var i=0; i&lt;aDiv.length; i++)&#123; var aSpan = aDiv[i].getElementsByClassName('future_info'); aSpan[0].innerHTML = data[i+1].days; aSpan[1].innerHTML = data[i+1].week; aSpan[2].innerHTML =data[i+1].weather; aSpan[3].innerHTML = data[i+1].temperature; &#125;//根据返回数据，替换不同天气图片 changeImg(response);&#125;//请求今日天气详细数据回调函数function getTodayWeather(response)&#123; var oSpan = document.getElementsByClassName('info'); var data = response.results; oSpan[7].innerHTML=data[0].pm25; oSpan[8].innerHTML=data[0].index[4].zs; oSpan[9].innerHTML=data[0].index[1].zs; oSpan[10].innerHTML=data[0].index[2].zs; oSpan[11].innerHTML=data[0].index[0].zs;&#125;//根据获取到的数据更改页面中相应的图片function changeImg(data)&#123; var firstImg = document.getElementsByTagName(\"img\")[0]; var firstWeatherId=data.result[0].weatid; chooseImg(firstWeatherId,firstImg); var aImg = document.getElementById('future_container').getElementsByTagName('img'); for(var j=0; j&lt;aImg.length; j++)&#123; var weatherId = data.result[j+1].weatid; chooseImg(weatherId,aImg[j]); &#125;&#125;//选择图片function chooseImg(id,index)&#123; switch(id)&#123; case '1': index.src='images/weather_icon/1.png'; break; case '2': index.src='images/weather_icon/2.png'; break; case '3': index.src='images/weather_icon/3.png'; break; case '4': case '5': case '6': case '8': case '9': case '10': case '11': case '12': case '13': case '20': case '22': case '23': case '24': case '25': case '26': index.src='images/weather_icon/4.png'; break; case '7': index.src='images/weather_icon/6.png'; break; case '14': case '15': case '16': case '17': case '18': case '27': case '28': case '29': index.src='images/weather_icon/5.png'; break; case '19': case '21': case '30': case '31': case '32': case '33': index.src='images/weather_icon/7.png'; break; default: index.src='images/weather_icon/8.png'; &#125;&#125;//根据城市名创建请求数据及urlfunction createUrl()&#123; var cityName = ''; if(arguments.length == 0) &#123; cityName = document.getElementById('text').value; &#125;else&#123; cityName = arguments[0]; &#125; var urls = []; urls[0] = 'https://sapi.k780.com/?app=weather.future&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json&amp;jsoncallback=getWeather&amp;weaid=' + encodeURI(cityName); urls[1] = 'https://api.map.baidu.com/telematics/v3/weather?output=json&amp;ak=FK9mkfdQsloEngodbFl4FeY3&amp;callback=getTodayWeather&amp;location=' + encodeURI(cityName); return urls;&#125; 实现过程很简单，代码量也不大，有兴趣的朋友可以自己动手试试，当然，若是能给我个star就再好不过了(^_^)","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zsqosos.github.io/tags/javascript/"}]},{"title":"关于setInterval和setTimeout中的this指向问题","date":"2016-12-16T11:22:52.000Z","path":"posts/program/20161216-setinterval-this/","text":"问题描述前些天在练习写一个小例子的时候用到了定时器，发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象，如下例： 123456789101112131415var num = 0;function Obj ()&#123; this.num = 1, this.getNum = function()&#123; console.log(this.num); &#125;, this.getNumLater = function()&#123; setTimeout(function()&#123; console.log(this.num); &#125;, 1000) &#125;&#125;var obj = new Obj; obj.getNum();//1 打印的为obj.num，值为1obj.getNumLater()//0 打印的为window.num，值为0 问题原因从上述例子中可以看到setTimeout中函数内的this是指向了window对象，这是由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。 这会导致这些代码中包含的 this 关键字会指向 window (或全局)对象。详细可参考MDN setTimeout 解决方法 1.将当前对象的this存为一个变量，定时器内的函数利用闭包来访问这个变量，如下： 12345678910111213141516var num = 0;function Obj ()&#123; var that = this; //将this存为一个变量，此时的this指向obj this.num = 1, this.getNum = function()&#123; console.log(this.num); &#125;, this.getNumLater = function()&#123; setTimeout(function()&#123; console.log(that.num); //利用闭包访问that，that是一个指向obj的指针 &#125;, 1000) &#125;&#125;var obj = new Obj; obj.getNum();//1 打印的是obj.num，值为1obj.getNumLater()//1 打印的是obj.num，值为1 这种方法是将当前对象的引用放在一个变量里，定时器内部的函数来访问到这个变量，自然就可以得到当前的对象。 2.利用bind()方法 123456789101112131415var num = 0;function Obj ()&#123; this.num = 1, this.getNum = function()&#123; console.log(this.num); &#125;, this.getNumLater = function()&#123; setTimeout(function()&#123; console.log(this.num); &#125;.bind(this), 1000) //利用bind()将this绑定到这个函数上 &#125;&#125;var obj = new Obj; obj.getNum();//1 打印的是obj.num，值为1obj.getNumLater()//1 打印的是obj.num，值为1 bind方法是在Function.prototype上的一个方法，当被绑定函数执行时，bind方法会创建一个新函数，并将第一个参数作为新函数运行时的this。在这个例子中，在调用setTimeout中的函数时，bind方法创建了一个新的函数，并将this传进新的函数，执行的结果也就是正确的了。关于bind方法可参考 MDN bind 3.箭头函数 123456789101112131415var num = 0;function Obj ()&#123; this.num = 1, this.getNum = function()&#123; console.log(this.num); &#125;, this.getNumLater = function()&#123; setTimeout(() =&gt; &#123; console.log(this.num); &#125;, 1000) //箭头函数中的this总是指向外层调用者，也就是Obj &#125;&#125;var obj = new Obj; obj.getNum();//1 打印的是obj.num，值为1obj.getNumLater()//1 打印的是obj.num，值为1 ES6中的箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj，利用箭头函数就可以轻松解决这个问题。 小结以上三种方法都是比较常用的，当然如果使用call或apply方法来代替bind方法，得到的结果也是正确的，但是call方法会在调用之后立即执行，那样也就没有了延时的效果，定时器也就没有用了，所以推荐使用上述方法来将this传进setTimeout和setInterval中。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zsqosos.github.io/tags/javascript/"}]},{"title":"jQuery轮播图——轮播实现并封装","date":"2016-12-12T11:22:52.000Z","path":"posts/program/20161212-jquery-carousel/","text":"介绍使用jQuery完成的简单轮播图组件，可在同一页面多个组件同时轮播。轮播图的实现过程并不复杂，但在是在封装过程中，运用到较多基础知识点，有面向对象、prototype继承、原型链等等。 demo预览：点此预览 代码地址： https://github.com/zsqosos/component_library/tree/master/jquery-carousel 文章首发：jQuery轮播图（一）轮播实现并封装 代码html: 123456789101112&lt;div class=\"banner\" id=\"J_bg_ban1\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/banner_01.jpg\" alt=\"广告图\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/banner_02.jpg\" alt=\"广告图\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/banner_03.jpg\" alt=\"广告图\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/banner_04.jpg\" alt=\"广告图\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/banner_05.jpg\" alt=\"广告图\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"indicator\" id=\"J_bg_indicator1\"&gt;&lt;/div&gt; &lt;div class=\"ban-btn clearfloat\" id=\"J_bg_btn1\"&gt; &lt;a class=\"next-btn fr\" href=\"javascript:\"&gt;&amp;gt;&lt;/a&gt;&lt;a class=\"prev-btn fl\" href=\"javascript:\"&gt;&amp;lt;&lt;/a&gt; &lt;/div&gt; css: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364.banner &#123; height: 325px; width: 812px; position: relative; overflow: hidden;&#125;.banner ul&#123; padding: 0; margin: 0;&#125;.banner ul li&#123; top: 0; left: 0; list-style: none; position: absolute;&#125;.banner ul li img&#123; height: 325px; width: 812px; display: block;&#125;.ban-btn&#123; width: 100%; position: absolute; top: 136px; z-index: 2;&#125;.ban-btn a&#123; display: inline-block; height: 60px; width: 35px; background: rgba(180,180,180,0.5); font-size: 25px; text-align: center; line-height: 60px; color: #fff; text-decoration: none;&#125;.next-btn&#123; float: right;&#125;.prev-btn&#123; float: left;&#125;.ban-btn a:hover&#123; background: rgba(100, 100, 100, 0.5);&#125;.indicator&#123; width: 100%; position: absolute; text-align: center; bottom: 15px; z-index: 2;&#125;.indicator a&#123; display: inline-block; width: 20px; height: 5px; margin:0 3px; background: #fff;&#125;.indicator-active&#123; background: #FF8C00;&#125; js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function Carousel(bannnerBox, aBox, btnBox)&#123; this.now = 0; //当前显示的图片索引 this.hasStarted = false； //是否开始轮播 this.interval = null； //定时器 this.liItems = null； //要轮播的li元素集合 this.len = 0; //liItems的长度 this.aBox : null; //包含指示器的dom对象 this.bBox : null; //包含前后按钮的dom对象 /** * 初始化及控制函数 * @param bannnerBox string 包含整个轮播图盒子的id或class * @param aBox string 包含指示器的盒子的id或class * @param btnBox string 包含前后按钮的盒子的id或class */ this.init = function() &#123; //初始化对象参数 var that = this; this.liItems = $(bannnerBox).find('ul').find('li'); this.len = this.liItems.length; this.aBox = $(bannnerBox).find(aBox); this.bBox = $(bannnerBox).find(btnBox); //让第一张图片显示，根据轮播图数量动态创建指示器，并让第一个指示器处于激活状态，隐藏前后按钮 this.liItems.first('li').css(&#123;'opacity': 1, 'z-index': 1&#125;).siblings('li').css(&#123;'opacity': 0, 'z-index': 0&#125;); var aDom = ''; for (var i = 0; i &lt; this.len; i++)&#123; aDom += '&lt;a&gt;&lt;/a&gt;'; &#125; $(aDom).appendTo(this.aBox); this.aBox.find('a:first').addClass(\"indicator-active\"); this.bBox.hide(); //鼠标移入banner图时，停止轮播并显示前后按钮，移出时开始轮播并隐藏前后按钮 $(bannnerBox).hover(function ()&#123; that.stop(); that.bBox.fadeIn(200); &#125;, function ()&#123; that.start(); that.bBox.fadeOut(200); &#125;); //鼠标移入指示器时，显示对应图片，移出时继续播放 this.aBox.find('a').hover(function ()&#123; that.stop(); var out = that.aBox.find('a').filter('.indicator-active').index(); that.now = $(this).index(); if(out!=that.now) &#123; that.play(out, that.now) &#125; &#125;, function ()&#123; that.start(); &#125;); //点击左右按钮时显示上一张或下一张 $(btnBox).find('a:first').click(function()&#123;that.next()&#125;); $(btnBox).find('a:last').click(function()&#123;that.prev()&#125;); &#125;; //前一张函数 this.prev = function ()&#123; var out = this.now; this.now = (--this.now + this.len) % this.len; this.play(out, this.now); &#125;; //后一张函数 this.next = function ()&#123; var out = this.now; this.now = ++this.now % this.len; this.play(out, this.now); &#125;; /** * 播放函数 * @param out number 要消失的图片的索引值 * @param now number 接下来要轮播的图的索引值 */ this.play = function (out, now)&#123; this.liItems.eq(out).stop().animate(&#123;opacity:0,'z-index':0&#125;,500).end().eq(now).stop().animate(&#123;opacity:1,'z-index':1&#125;,500); this.aBox.find('a').removeClass('indicator-active').eq(now).addClass('indicator-active'); &#125;; //开始函数 this.start = function()&#123; if(!this.hasStarted) &#123; this.hasStarted = true; var that = this; this.interval = setInterval(function()&#123; that.next(); &#125;,2000); &#125; &#125;; //停止函数 this.stop = function ()&#123; clearInterval(this.interval); this.hasStarted = false; &#125; // 初始化 this.init(); // 开始轮播 this.start();&#125;; 调用时采用new操作符，如下： 12var banner1 = new Carousel('#J_bg_ban1','#J_bg_indicator1','#J_bg_btn1');var banner2 = new Carousel('#J_bg_ban2','#J_bg_indicator2','#J_bg_btn2'); 存在问题这里使用了构造函数来实现继承，上述代码虽然可以实现轮播需求，但是仔细分析发现，每次使用new操作符都会根据构造函数构建出造出一个新的实例对象，那就存在内部函数不能复用的缺点，这也是单独使用构造函数来自定义对象不可避免的。 在Carousel对象内的play方法、next方法、prev方法、strat方法、stop方法其实都是可以共用的，多个轮播件共用这些函数是完全没有问题的，而init初始化方法需要在每个实例上单独创建。单独使用构造函数创建对象，在使用new操作符创建新实例的时候，init初始化方法会被重新在每个实例上创建一遍，这正是我们想要的结果，而play方法、next方法、prev方法、start方法、stop方法这些可共用的方法也会在新实例上被重新创建，而创造多个完成一样任务的方法是完全没有必要的，所以需要将这些共有的方法提出来，让所有Carousel对象的实例都可以公用，这样就可以解决函数复用的问题。 改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 构造函数加原型形式 /** * 构造函数初始化及开始轮播 * @param bannnerBox string 包含整个轮播图盒子的id或class * @param aBox string 包含指示器的盒子的id或class * @param btnBox string 包含前后按钮的盒子的id或class */ function Carousel(bannnerBox, aBox, btnBox) &#123; this.now = 0; //当前显示的图片索引 this.hasStarted = false; //是否开始轮播 this.interval = null; //定时器 this.liItems = null; //要轮播的li元素集合 this.len = 0; //liItems的长度 this.aBox = null; //包含指示器的dom对象 this.bBox = null; //包含前后按钮的dom对象 //初始化函数 this.init = function () &#123; //初始化对象参数 var that = this; this.liItems = $(bannnerBox).find('ul').find('li'); this.len = this.liItems.length; this.aBox = $(bannnerBox).find(aBox); this.bBox = $(bannnerBox).find(btnBox); //让第一张图片显示，根据轮播图数量动态创建指示器，并让第一个指示器处于激活状态，隐藏前后按钮 this.liItems.first('li').css(&#123; 'opacity': 1, 'z-index': 1 &#125;).siblings('li').css(&#123; 'opacity': 0, 'z-index': 0 &#125;); var aDom = ''; for (var i = 0; i &lt; this.len; i++) &#123; aDom += '&lt;a&gt;&lt;/a&gt;'; &#125; $(aDom).appendTo(this.aBox); this.aBox.find('a:first').addClass(\"indicator-active\"); this.bBox.hide(); //鼠标移入banner图时，停止轮播并显示前后按钮，移出时开始轮播并隐藏前后按钮 $(bannnerBox).hover(function () &#123; that.stop(); that.bBox.fadeIn(200); &#125;, function () &#123; that.start(); that.bBox.fadeOut(200); &#125;); //鼠标移入指示器时，显示对应图片，移出时继续播放 this.aBox.find('a').hover(function () &#123; that.stop(); var out = that.aBox.find('a').filter('.indicator-active').index(); that.now = $(this).index(); if (out != that.now) &#123; that.play(out, that.now) &#125; &#125;, function () &#123; that.start(); &#125;); //点击左右按钮时显示上一张或下一张 $(btnBox).find('a:first').click(function () &#123; that.next() &#125;); $(btnBox).find('a:last').click(function () &#123; that.prev() &#125;); &#125; //初始化 this.init(); //开始轮播 this.start(); &#125; /** * 播放函数 * @param out number 要消失的图片的索引值 * @param now number 接下来要轮播的图的索引值 */ Carousel.prototype.play = function (out, now) &#123; this.liItems.eq(out).stop().animate(&#123; opacity: 0, 'z-index': 0 &#125;, 500).end().eq(now).stop().animate(&#123; opacity: 1, 'z-index': 1 &#125;, 500); this.aBox.find('a').removeClass('indicator-active').eq(now).addClass('indicator-active'); &#125; //前一张函数 Carousel.prototype.prev = function () &#123; var out = this.now; this.now = (--this.now + this.len) % this.len; this.play(out, this.now) &#125; //后一张函数 Carousel.prototype.next = function () &#123; var out = this.now; this.now = ++this.now % this.len; this.play(out, this.now); &#125; //开始函数 Carousel.prototype.start = function () &#123; if (!this.hasStarted) &#123; this.hasStarted = true; var that = this; this.interval = setInterval(function () &#123; that.next(); &#125;, 2000); &#125; &#125; //停止函数 Carousel.prototype.stop = function () &#123; clearInterval(this.interval); this.hasStarted = false; &#125; $(function () &#123; var banner1 = new Carousel('#J_bg_ban1', '#J_bg_indicator1', '#J_bg_btn1'); var banner2 = new Carousel('#J_bg_ban2', '#J_bg_indicator2', '#J_bg_btn2'); &#125;); 在这里对Carousel对象的原型对象进行了扩展，将play方法、next方法，perv方法，start方法和stop方法写进了Carousel的原型对象中，这样每次实例化的对象就可以共用这些方法。当然，实例化的时候也是使用new操作符。这样我们就可以在同一页面内多次使用这个轮播对象了。这种组合使用构造函数和原型的模式，是创建自定义类型最常用的方法，至此我们就完成了这个简单轮播对象的封装。 小结本文是在我开始学习JavaScript继承时，对原型继承的一些理解和运用。文中所述的继承方式均是使用js特有的原型链方式，实际上有了ES6的类之后，实现继承的就变得十分简单了，所以这种写法现在也不在推荐使用了，对于对象的继承更推荐使用ES6的class来实现。","tags":[{"name":"组件","slug":"组件","permalink":"http://zsqosos.github.io/tags/组件/"},{"name":"jQuery","slug":"jQuery","permalink":"http://zsqosos.github.io/tags/jQuery/"}]},{"title":"丰子恺——《我与弘一法师》","date":"1994-08-27T16:00:01.000Z","path":"posts/extract/19940828-mr-feng-speech-in-xiamen/","text":"弘一法师是我学艺术的教师，又是我信宗教的导师。我的一生，受法师影响很大。厦门是法师近年经行之地，据我到此三天内所见，厦门人士受法师的影响也很大，故我与厦门人士不啻都是同窗弟兄。今天佛学会要我演讲，我惭愧修养浅薄，不能讲弘法利生的大义，只能把我从弘一法师学习艺术宗教时的旧事，向诸位同窗弟兄谈谈，还请赐我指教。 我十七岁入杭州浙江第一师范，廿岁毕业以后没有升学。我受中等学校以上学校教育，只此五年。这五年间，弘一法师，那时称为李叔同先生，便是我的图画音乐教师。图画音乐两科，在现在的学校里是不很看重的，但是奇怪得很，在当时我们的那间浙江第一师范里，看得比英、国、算还重。我们有两个图画专用的教室，许多石膏模型，两架钢琴，五十几架风琴。我们每天要花一小时去练习图画，花一小时以上去练习弹琴。大家认为当然，恬不为怪，这是什么原故呢?因为李先生的人格和学问，统制了我们的感情，折服了我们的心。他从来不骂人，从来不责备人，态度谦恭，同出家后完全一样，然而个个学生真心的怕他，真心的学习他，真心的崇拜他。我便是其中之一人。因为就人格讲，他的当教师不为名利，为当教师而当教师，用全副精力去当教师。就学问讲，他博学多能，其国文比国文先生更高，其英文比英文先生更高，其历史比历史先生更高，其常识比博物先生更富，又是书法金石的专家，中国话剧的鼻祖。他不是只能教图画音乐，他是拿许多别的学问为背景而教他的图画音乐。夏丐尊先生曾经说，“李先生的教师，是有后光的。”像佛菩萨那样有后光，怎不教人崇拜呢？而我的崇拜他，更甚于他人。大约是我的气质与李先生有一点相似，凡他所欢喜的，我都欢喜。我在师范学校，一二年级都考第一名；三年级以后忽然降到第二十名，因为我旷废了许多师范生的功课，而专心于李先生所喜的文学艺术，一直到毕业。毕业后我无力升大学，借了些钱到日本去游玩，没有进学校，看了许多画展，听了许多音乐会，买了许多文艺书，一年后回国，一方面当教师，一方面埋头自习，一直自习到现在，对李先生的艺术还是迷恋不舍。李先生早已由艺术而升华到宗教而成正果，而我还彷徨在艺术宗教的十字街头，自己想想，真是一个不肖的学生。 他怎么由艺术升华到宗教呢?当时人都诧异，以为李先生受了什么刺激，忽然“遁入空门”了。我却能理解他的心，我认为他的出家是当然的。我以为人的生活，可以分作三层：一是物质生活，二是精神生活，三是灵魂生活。物质生活就是衣食。精神生活就是学术文艺。灵魂生活就是宗教。“人生”就是这样的一个三层楼。懒得(或无力)走楼梯的，就住在第一层，即把物质生活弄得很好，锦衣玉食，尊荣富贵，孝子慈孙，这样就满足了。这也是一种人生观。抱这样的人生观的人，在世间占大多数。其次，高兴(或有力)走楼梯的，就爬上二层楼去玩玩，或者久居在里头。这就是专心学术文艺的人。他们把全力贡献于学问的研究，把全心寄托于文艺的创作和欣赏。这样的人，在世间也很多，即所谓“知识分子”，“学者”，“艺术家，”。还有一种人，“人生欲”很强，脚力很大，对二层楼还不满足，就再走楼梯，爬上三层楼去。这就是宗教徒了。他们做人很认真，满足了“物质欲”还不够，满足了“精神欲”还不够，必须探求人生的究竟。他们以为财产子孙都是身外之物，学术文艺都是暂时的美景，连自己的身体都是虚幻的存在。他们不肯做本能的奴隶，必须追究灵魂的来源，宇宙的根本，这才能满足他们的“人生欲”。这就是宗教徒。世间就不过这三种人。我虽用三层楼为比喻，但并非必须从第一层到第二层，然后得到第三层。有很多人，从第一层直上第三层，并不需要在第二层勾留。还有许多人连第一层也不住，一口气跑上三层楼。不过我们的弘一法师，是一层一层的走上去的。弘一法师的“人生欲”非常之强！他的做人，一定要做得彻底。他早年对母尽孝，对妻子尽爱，安住在第一层楼中。中年专心研究艺术，发挥多方面的天才，便是迁居在二层楼了。强大的“人生欲”不能使他满足于二层楼，于是爬上三层楼去，做和尚，修净土，研戒律，这是当然的事，毫不足怪的。做人好比喝酒；酒量小的，喝一杯花雕酒已经醉了，酒量大的，喝花雕嫌淡，必须喝高粱酒才能过瘾。文艺好比是花雕，宗教好比是高梁。弘一法师酒量很大，喝花雕不能过瘾，必须喝高粱。我酒量很小，只能喝花雕，难得喝一口高梁而已。但喝花雕的人，颇能理解喝高梁者的心。故我对于弘一法师的由艺术升华到宗教，一向认为当然，毫不足怪的。 艺术的最高点与宗教相接近。二层楼的扶梯的最后顶点就是三层楼，所以弘一法师由艺术升华到宗教，是必然的事。弘一法师在闽中，留下不少的墨宝。这些墨宝，在内容上是宗教的，在形式上是艺术的——书法。闽中人士久受弘一法师的熏陶，大都富有宗教信仰及艺术修养。我这初次入闽的人，看见这情形，非常歆羡，十分钦佩！ 前天参拜南普陀寺，承广洽法师的指示，瞻观弘一法师的故居及其手种杨柳，又看到他所创办的佛教养正院。广义法师要我为养正院书联，我就集唐人诗句：“须知诸相皆非相，能使无情尽有情”，写了一副。这对联挂在弘一法师所创办的佛教养正院里，我觉得很适当。因为上联说佛经，下联说艺术，很可表明弘一法师由艺术升华到宗教的意义。艺术家看见花笑，听见鸟语，举杯邀明月，开门迎白云，能把自然当作人看，能化无情为有情，这便是“物我一体”的境界。更进一步，便是“万法从心”、“诸相非相”的佛教真谛了。故艺术的最高点与宗教相通。最高的艺术家有言：“无声之诗无一字，无形之画无一笔。”可知吟诗描画，平平仄仄，红红绿绿，原不过是雕虫小技，艺术的皮毛而已，艺术的精神，正是宗教的。古人云：“文章一小技，于道未为尊。”又曰：“太上立德，其次立言。”弘一法师教人，亦常引用儒家语：“士先器识而后文艺。”所谓“文章”’“言”，“文艺”，便是艺术，所谓“道”，“德”，“器识”，正是宗教的修养。宗教与艺术的高下重轻，在此已经明示，三层楼当然在二层楼之上的。 我脚力小，不能追随弘一法师上三层楼，现在还停留在二层楼上，斤斤于一字一笔的小技，自己觉得很惭愧。但亦常常勉力爬上扶梯，向三层楼上望望。故我希望：学宗教的人，不须多花精神去学艺术的技巧，因为宗教已经包括艺术了。而学艺术的人，必须进而体会宗教的精神，其艺术方有进步。久驻闽中的高僧，我所知道的还有一位太虚法师。他是我的小同乡，从小出家的。他并没有弄艺术，是一口气跑上三层楼的。但他与弘一法师，同样地是旷世的高僧，同样地为世人所景仰。可知在世间，宗教高于一切。在人的修身上，器识重于一切。太虚法师与弘一法师，异途同归，各成正果。文艺小技的能不能，在大人格上是毫不足道的。我愿与闽中人士以二法师为模范而共同勉励。 ——厦门佛学会讲稿，民国卅七年十一月廿八日 丰子恺","tags":[{"name":"摘录杂文","slug":"摘录杂文","permalink":"http://zsqosos.github.io/tags/摘录杂文/"}]}]