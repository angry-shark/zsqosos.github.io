[{"title":"原生js实现天气查询小应用","date":"2017-04-16T08:55:40.000Z","path":"posts/program/20170416-weather/","text":"介绍用原生js实现了一个简单的小应用，可以用来查询全国天气，主要实现了以下两个功能 点开链接时，页面自动获取当前所在城市，并显示所在城市的天气信息 在搜索栏搜索要查询的城市，可显示要查询城市的天气信息 页面效果如下： 预览 在线预览 完整代码 请使用高级浏览器查看，预览时若速度较慢，请耐心等待 实现原理1.用jsonp的方式请求天气数据由于现有免费天气api较少，在此推荐两个api nowapi 百度地图开放平台 这两者都是可以免费使用的，nowapi的免费天气数据可以提供未来7天天气数据，百度地图的api可以提供当前所在地理位置及当日天气详情，结合使用基本可以满足个人需求 百度天气api测试示例：http://api.map.baidu.com/telematics/v3/weather?location=西安&amp;output=json&amp;ak=FK9mkfdQsloEngodbFl4FeY3 newapi天气api测试示例：http://api.k780.com:88/?app=weather.future&amp;weaid=1&amp;&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json) 以上地址仅供测试使用，若需使用，请单独申请key。另外，以上数据接口均支持https，并支持jsonp调用 jsonp方式的数据请求函数 123456function jsonp(url)&#123; var script = document.createElement('script'); script.src = url; document.body.insertBefore(script, document.body.firstChild); document.body.removeChild(script);&#125; 将上述天气api地址传入此函数，便可得到天气数据，对于请求所需参数及返回数据格式请参考官方api文档，在此不再赘述。采用jsonp的方式可以完美解决跨域的问题，但需注意一点，使用https协议的站点也只能调用支持https的api接口 返回数据如下 返回的数据为json格式，由于我的chrome安装了JSONview插件，所以可以看到格式化后的json数据 2.将返回数据展示在页面上这一步比较简单，主要是用js操作dom，将对应的数据填在页面相应的位置上，除了文字数据外，还需对天气图标进行操作，使之与天气相对应。返回的数据中已含有天气图标url，只需根据返回数据动态改变原有html中img的src即可。但由于以上api所提供的天气图标太丑，所以我采用了自己的天气图标来替换 主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//调用jsonp函数请求当前所在城市jsonp('https://api.map.baidu.com/api?v=2.0&amp;ak=Dv1NMU23dh1sGS9n2tUouDEYY96Dfzh3&amp;s=1&amp;callback=getCity');window.onload=function()&#123; //请求天气车数据 btn.onclick=function ()&#123; jsonp(createUrl()[0]); jsonp(createUrl()[1]); &#125;&#125;;function getCity()&#123; function city(result)&#123; //去掉城市名后的\"市\" var city = result.name.substring(0,result.name.length-1); //请求当前城市的天气数据 jsonp(createUrl(city)[0]); jsonp(createUrl(city)[1]); &#125; var cityName = new BMap.LocalCity(); cityName.get(city);&#125;// 数据请求函数function jsonp(url)&#123; var script = document.createElement('script'); script.src = url; document.body.insertBefore(script, document.body.firstChild); document.body.removeChild(script);&#125;//数据请求成功回调函数，用于将获取到的数据放入页面相应位置function getWeather(response) &#123; var oSpan = document.getElementsByClassName('info'); var data = response.result; oSpan[0].innerHTML=data[0].citynm; oSpan[1].innerHTML=data[0].days; oSpan[2].innerHTML=data[0].week; oSpan[3].innerHTML=data[0].weather; oSpan[4].innerHTML=data[0].temperature; oSpan[5].innerHTML=data[0].winp; oSpan[6].innerHTML=data[0].wind; var aDiv = document.getElementsByClassName('future_box'); for(var i=0; i&lt;aDiv.length; i++)&#123; var aSpan = aDiv[i].getElementsByClassName('future_info'); aSpan[0].innerHTML = data[i+1].days; aSpan[1].innerHTML = data[i+1].week; aSpan[2].innerHTML =data[i+1].weather; aSpan[3].innerHTML = data[i+1].temperature; &#125;//根据返回数据，替换不同天气图片 changeImg(response);&#125;//请求今日天气详细数据回调函数function getTodayWeather(response)&#123; var oSpan = document.getElementsByClassName('info'); var data = response.results; oSpan[7].innerHTML=data[0].pm25; oSpan[8].innerHTML=data[0].index[4].zs; oSpan[9].innerHTML=data[0].index[1].zs; oSpan[10].innerHTML=data[0].index[2].zs; oSpan[11].innerHTML=data[0].index[0].zs;&#125;//根据获取到的数据更改页面中相应的图片function changeImg(data)&#123; var firstImg = document.getElementsByTagName(\"img\")[0]; var firstWeatherId=data.result[0].weatid; chooseImg(firstWeatherId,firstImg); var aImg = document.getElementById('future_container').getElementsByTagName('img'); for(var j=0; j&lt;aImg.length; j++)&#123; var weatherId = data.result[j+1].weatid; chooseImg(weatherId,aImg[j]); &#125;&#125;//选择图片function chooseImg(id,index)&#123; switch(id)&#123; case '1': index.src='images/weather_icon/1.png'; break; case '2': index.src='images/weather_icon/2.png'; break; case '3': index.src='images/weather_icon/3.png'; break; case '4': case '5': case '6': case '8': case '9': case '10': case '11': case '12': case '13': case '20': case '22': case '23': case '24': case '25': case '26': index.src='images/weather_icon/4.png'; break; case '7': index.src='images/weather_icon/6.png'; break; case '14': case '15': case '16': case '17': case '18': case '27': case '28': case '29': index.src='images/weather_icon/5.png'; break; case '19': case '21': case '30': case '31': case '32': case '33': index.src='images/weather_icon/7.png'; break; default: index.src='images/weather_icon/8.png'; &#125;&#125;//根据城市名创建请求数据及urlfunction createUrl()&#123; var cityName = ''; if(arguments.length == 0) &#123; cityName = document.getElementById('text').value; &#125;else&#123; cityName = arguments[0]; &#125; var urls = []; urls[0] = 'https://sapi.k780.com/?app=weather.future&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json&amp;jsoncallback=getWeather&amp;weaid=' + encodeURI(cityName); urls[1] = 'https://api.map.baidu.com/telematics/v3/weather?output=json&amp;ak=FK9mkfdQsloEngodbFl4FeY3&amp;callback=getTodayWeather&amp;location=' + encodeURI(cityName); return urls;&#125; 实现过程很简单，代码量也不大，有兴趣的朋友可以自己动手试试，当然，若是能给我个star就再好不过了(^_^)","tags":[{"name":"javascript","slug":"javascript","permalink":"http://zsqosos.github.io/tags/javascript/"}]},{"title":"三月的北京","date":"2017-03-20T12:48:38.000Z","path":"posts/life/20170320-life/","text":"漫天飞舞的柳絮，随着耳机里熟悉的旋律飘进了我的心。初来北京，虽说正值春日，但除了每日的工作和学习，还未曾出门踏踏青。我并不是一个喜欢游玩的人，但出门看到一番好景致自会让人心情大好。看着眼前的场景，我想，三月的北京似乎和别处一样，但似乎又不一样。玉渊潭那熙熙攘攘的赏花者和别处并没什么不同，连园子里的花也和别处一样，而这里的热闹却是别处没有的。年年均有花开时，花开自会惹人赏。而今旧人非今人，此花亦非旧时花。我似乎来的正是时候，有幸目睹今年盛开的樱花。 三月的北京很柔弱，处处都是一副惹人怜的模样路边轻摆的杨柳湖上悠悠的小船还有街上那美丽的姑娘 三月的北京也很豪壮有胡同里一口京腔骂仗的少年也有紫禁城为为壮阔的雄景更有无数人为之努力的梦想 在这座城市里每天都有许多人为了生活而奔波更有人为了梦想而奋斗有人在这里看到了无尽的黑暗有人在这里看到了希望之光我想人生的意义可能不在于得到什么，而在于做了什么三月的北京是什么？不是美景是希望","tags":[]},{"title":"两种最常用的Sticky footer布局方式","date":"2017-02-08T11:22:52.000Z","path":"posts/program/20170208-stickyfooter/","text":"Sticky footer布局是什么？我们所见到的大部分网站页面，都会把一个页面分为头部区块、内容区块和页脚区块，当头部区块和内容区块内容较少时，页脚能固定在屏幕的底部，而非随着文档流排布。当页面内容较多时，页脚能随着文档流自动撑开，显示在页面的最底部，这就是Sticky footer布局。 图示说明 当内容较少时，正常的文档流效果如下图 在正常的文档流中，页面内容较少时，页脚部分不是固定在视窗底部的，这时就要用到Stickyfooter布局。 Sticky footer布局效果如下图 这样就符合我们的预期效果，可以看出Sticky footer布局的应用场景还是非常广泛的。 实现方式负margin布局方式html代码： 12345678&lt;div class=\"wrapper clearfix\"&gt; &lt;div class=\"content\"&gt; // 这里是页面内容 &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt; // 这里是footer的内容&lt;/div&gt; css代码：12345678910111213141516171819202122.wrapper &#123; min-height: 100%;&#125;.wrapper .content&#123; padding-bottom: 50px; /* footer区块的高度 */&#125;.footer &#123; position: relative; margin-top: -50px; /* 使footer区块正好处于content的padding-bottom位置 */ height: 50px; clear: both;&#125;.clearfix::after &#123; display: block; content: \".\"; height: 0; clear: both; visibility: hidden;&#125; 注意:content元素的padding-bottom、footer元素的高度以及footer元素的margin-top值必须要保持一致。 这种负margin的布局方式，是兼容性最佳的布局方案，各大浏览器均可完美兼容，适合各种场景，但使用这种方式的前提是必须要知道footer元素的高度，且结构相对较复杂。 flex布局方式html代码： 1234&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;这里是主要内容&lt;/div&gt; &lt;div class=\"footer\"&gt;这是页脚区块&lt;/div&gt;&lt;/div&gt; css代码： 1234567891011.wrapper &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;.content &#123; flex: 1;&#125;.footer &#123; flex: 0;&#125; 这中布局方式结构简单，代码量少，也是较为推荐的布局方式。 小结Sticky footer布局是十分常见的一种页面布局形式，实现的手段也比较多，以上两种方法最为常用，且基本可以满足所有应用场景。","tags":[{"name":"css","slug":"css","permalink":"http://zsqosos.github.io/tags/css/"}]}]